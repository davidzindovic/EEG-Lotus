// kar je zakomentirano je poskus gradienta barv (bi moral delat)

#include <Mindwave.h>

//#define MINDWAVE_BAUDRATE 57600
#define MAX_SPREMEMBA 8 // prilagajaÅ¡ glede na navor,(100/(MAX_ST_OBRATOV/ST_OBRATOV_NA_S)
#define ST_OBRATOV_NA_S 1
#define MAX_ST_OBRATOV 6
//npr. omejitev da je 1obr/s najvec

#define HITROST_MOTORJA 2000
#define KORAKI_MOTORJA 2000

Mindwave mindwave;

int meditacija; int meditacija_prej=0; int regulacijsko_povprecje;
int motor;int delta_motor;
bool first=false;

unsigned int pozicija_cilj=0;  //cilj pozicije
unsigned int pozicija=0;       // dejanska pozicija
int stepsPerSecond = 0;


void setup() {
    //Condifure stepper driver pins as OUTPUTs
    pinMode(PIN_STEP1_DIRECTION, OUTPUT);
    pinMode(PIN_STEP1_STEP, OUTPUT);
    pinMode(PIN_STEP_ENABLE, OUTPUT);
    //Serial.begin(9600);
    //ENABLE pin has to be pulled LOW for TCM2209 used in this example to enable the driver
    digitalWrite(PIN_STEP_ENABLE, LOW); 
  Serial.begin(MINDWAVE_BAUDRATE);

}

void onMindwaveData() {

  meditacija = mindwave.meditation();
  //fokus = map(mindwave.attention(), 0, 100, 0, 255);
  // dodaj postanje v google sheets za statistiko
  
  //Serial.print("\tattention: ");
  //Serial.print(fokus);
  //Serial.print("\tmeditation: ");
  //Serial.println(meditacija);
  //Serial.println();
regulacija(meditacija);

}

void regulacija(unsigned int trenutno_stanje)
{

if(first!=false || trenutno_stanje!=0)
{
 if (first==false)
  {
  if(trenutno_stanje!=meditacija_prej)meditacija_prej=trenutno_stanje;//regulacija(meditacija_prej,trenutno_stanje);
  first=!first;
  }
 else
  {
   if(trenutno_stanje>meditacija_prej)regulacijsko_povprecje=(trenutno_stanje-(trenutno_stanje-meditacija_prej)/2);
   else regulacijsko_povprecje=(trenutno_stanje+(-trenutno_stanje+meditacija_prej)/2);
   meditacija_prej=trenutno_stanje;
  }
}

 if(abs(regulacijsko_povprecje-motor)>MAX_SPREMEMBA) delta_motor=MAX_SPREMEMBA*(regulacijsko_povprecje-motor)/abs(regulacijsko_povprecje-motor);
 else delta_motor=regulacijsko_povprecje-motor;

motor+=delta_motor;

/*// Za Serial Plotter:
Serial.print(trenutno_stanje);
Serial.print(",");
Serial.print(regulacijsko_povprecje);
Serial.print(",");
Serial.println(motor);*/

if (motor>100) motor=100;
else if (motor<0) motor=0;

// mappamo od 0 do max obratov (6)
pozicija_cilj=map(motor,0,100,0,9534);

while(pozicija!=pozicija_cilj)
{
  vrtenje(HITROST_MOTORJA,pozicija<pozicija_cilj,KORAKI_MOTORJA);
}
}

void vrtenje(int hitrost, bool smer, int stevilo_korakov)
{

if(smer) stepsPerSecond = hitrost;
else stepsPerSecond = -hitrost;

  
for(int i=stevilo_korakov;i>0;--i)
{
   if (((stepsPerSecond > 0) && (pozicija < 9534))||((stepsPerSecond < 0) && (pozicija>0)))
   {
    static unsigned long nextChange = 0;
    static uint8_t currentState = LOW;

    if (stepsPerSecond == 0)
    {
        //if speed is 0, set the step pin to LOW to keep current position
        currentState = LOW;
        digitalWrite(PIN_STEP1_STEP, LOW);
    }
    else
    {
        //if stepsPerSecond is not 0, then we need to calculate the next time to change the state of the driver
        if (micros() > nextChange)
        {

            //Generate steps
            if (currentState == LOW)
            {
                currentState = HIGH;
                nextChange = micros() + 30;

                if ((stepsPerSecond > 0) && (pozicija < 65535))
                {
                    pozicija++;
                }
                else if ((stepsPerSecond < 0) && (pozicija>0))
                {
                    pozicija--;
                }
            }
            else
            {
                currentState = LOW;
                nextChange = micros() + (1000 * abs(1000.0f / stepsPerSecond)) - 30;
            }

            //Set direction based on the sign of stepsPerSecond
            if (stepsPerSecond > 0)
            {
                digitalWrite(PIN_STEP1_DIRECTION, LOW);
            }
            else
            {
                digitalWrite(PIN_STEP1_DIRECTION, HIGH);
            }

            //Write out the step pin
            digitalWrite(PIN_STEP1_STEP, currentState);
        }
    }


}   }    
        digitalWrite(PIN_STEP1_STEP, LOW);
        //return pozicija;  
        }

void loop() {
  mindwave.update(Serial, onMindwaveData);
}
